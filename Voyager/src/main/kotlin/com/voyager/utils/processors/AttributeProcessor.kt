/**
 * Voyager Attribute Processing System
 * Copyright (c) 2024, Voyager Contributors
 *
 * Provides a high-performance, thread-safe system for registering custom attribute handlers
 * and applying attributes to Android [View] instances within the Voyager framework.
 * This system is optimized for efficient memory usage and speed, incorporating features like
 * type-safe attribute handling, optimized processing for ConstraintLayout attributes,
 * and prevention of redundant attribute applications using a bitmask.
 *
 * Key features:
 * - **Thread-safe Attribute Registration:** Allows defining custom attribute handlers at runtime.
 * - **Type-Safe Handlers:** Ensures that attribute values are applied correctly based on their type.
 * - **Optimized Application Order:** Processes attributes in a specific order (ID, normal, constraints, bias)
 *   for correctness and efficiency.
 * - **Duplicate Application Prevention:** Uses a [BitmaskManager] to avoid applying the same attribute
 *   multiple times to a single view during an inflation pass.
 * - **Memory Efficiency:** Uses [ConcurrentHashMap] with initial capacities and optimized string operations.
 *
 * @author Abdelrahman Omar
 */
package com.voyager.utils.processors

import android.view.View
import com.voyager.utils.partition
import com.voyager.utils.view.Attributes
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicInteger
import java.util.logging.Level
import java.util.logging.Logger
import kotlin.contracts.ExperimentalContracts
import kotlin.contracts.contract

/**
 * `AttributeProcessor` is a singleton object that serves as the core system for registering
 * and applying view attributes within the Voyager framework.
 *
 * It provides a centralized mechanism for defining how specific attributes (identified by a string name)
 * should affect a [View]. This includes handling type safety for attribute values and optimizing
 * the order and application of attributes, especially for complex layouts like `ConstraintLayout`.
 *
 * To define a custom attribute, use the [registerAttribute] method:
 * ```kotlin
 * // Example: Registering a custom 'customBackgroundColor' attribute for any View
 * AttributeProcessor.registerAttribute<View, Int>("customBackgroundColor") { view, colorInt ->
 *     view.setBackgroundColor(colorInt)
 * }
 * ```
 *
 * During layout inflation, [DynamicLayoutInflation] uses [applyAttributes] to efficiently
 * set all resolved attributes on a newly created view.
 *
 * @see AttributeHandler For the wrapper around individual attribute application logic.
 * @see BitmaskManager For the mechanism that prevents redundant attribute applications.
 * @see DynamicLayoutInflation The primary consumer of this processor.
 */
@PublishedApi
internal object AttributeProcessor {
    /**
     * Initial capacity for [ConcurrentHashMap] instances ([attributeHandlers], [attributeIds])
     * to reduce potential resizing operations during initial attribute registrations.
     */
    private const val INITIAL_CAPACITY = 32 // Default ConcurrentHashMap capacity is 16, this is slightly larger.

    /**
     * Number of bits in a `Long` value (64). Used for bit manipulation in [BitmaskManager].
     * `Long.SIZE_BITS` could be used if targeting Kotlin 1.3+.
     */
    private const val BITS_PER_LONG = 64 // Corrected to 64 for Long.SIZE_BITS

    /**
     * Bitmask for modulo operation with [BITS_PER_LONG]. Equivalent to `index % BITS_PER_LONG`.
     * Used to find the bit position within a `Long` in [BitmaskManager].
     * For 64 bits, this should be `0x3F` (binary `111111`).
     */
    private const val BIT_MASK = 0x3F

    /**
     * Initial size of the `LongArray` in [BitmaskManager].
     * Chosen to accommodate a reasonable number of attributes without immediate resizing.
     */
    private const val BITMAP_INITIAL_SIZE = 4 // (4 * 64 = 256 attributes)

    /**
     * Cached string prefix for identifying `ConstraintLayout` attributes to optimize string operations.
     */
    private const val LAYOUT_CONSTRAINT_PREFIX = "layout_constraint"

    /**
     * Cached string keyword for identifying `ConstraintLayout` bias attributes.
     */
    private const val BIAS_KEYWORD = "bias"

    /**
     * Lazy-initialized [Logger] for logging messages from the [AttributeProcessor].
     * Initialization is deferred until the first logging call to reduce startup overhead.
     */
    private val logger by lazy { Logger.getLogger(AttributeProcessor::class.java.name) }

    /**
     * Thread-safe map storing [AttributeHandler] instances, keyed by a unique integer ID
     * generated by [nextId]. Pre-sized to [INITIAL_CAPACITY].
     */
    internal val attributeHandlers = ConcurrentHashMap<Int, AttributeHandler>(INITIAL_CAPACITY) // Made internal for potential testing access

    /**
     * Thread-safe map storing unique integer IDs for each registered attribute name.
     * This allows for faster lookups (integer key vs string key) in [attributeHandlers]
     * and is used by [BitmaskManager]. Pre-sized to [INITIAL_CAPACITY].
     */
    internal val attributeIds = ConcurrentHashMap<String, Int>(INITIAL_CAPACITY) // Made internal for potential testing access

    /**
     * An [AtomicInteger] used to generate unique, sequential IDs for newly registered attributes.
     * Ensures thread-safe generation of IDs.
     */
    private val nextId = AtomicInteger(0)

    /**
     * Instance of [BitmaskManager] used to track which attributes have been applied to a view
     * during a single call to [applyAttributes], preventing redundant applications.
     */
    private val bitmask = BitmaskManager()

    /**
     * Registers a custom attribute handler for a specific [View] type and attribute value type.
     *
     * This function is thread-safe. If an attribute with the same `name` is registered multiple times,
     * the first registered handler will be used.
     *
     * The `handler` lambda will be invoked when [applyAttributes] encounters this attribute name.
     * Type safety is ensured by capturing `V` (View type) and `T` (value type) using reified generics,
     * and the [AttributeHandler] further checks types at runtime.
     *
     * @param V The specific subtype of [View] this attribute handler applies to (e.g., `TextView::class.java`).
     * @param T The expected type of the attribute's value (e.g., `String::class.java` for text).
     * @param name The unique name of the attribute (e.g., "custom:myTextColor", "android:text").
     *             It's recommended to use a namespace to avoid collisions.
     * @param handler A lambda function `(V, T) -> Unit` that takes the view instance (cast to `V`)
     *                and the attribute value (cast to `T`) and applies the attribute to the view.
     */
    inline fun <reified V : View, reified T> registerAttribute(
        name: String,
        crossinline handler: (V, T) -> Unit,
    ) {
        // Efficiently check if already registered.
        // computeIfAbsent is ideal but requires API 24 for ConcurrentHashMap.
        // This synchronized double-check pattern is a common alternative for lower API levels.
        var currentId = attributeIds[name]
        if (currentId == null) {
            synchronized(attributeIds) { // Synchronize on a shared, final object
                currentId = attributeIds[name] // Double-check
                if (currentId == null) {
                    val newId = nextId.getAndIncrement()
                    attributeIds[name] = newId
                    // Suppress UNCHECKED_CAST as reified types V and T are used for type safety
                    // within the AttributeHandler's apply method.
                    @Suppress("UNCHECKED_CAST")
                    attributeHandlers[newId] = AttributeHandler(
                        V::class.java, T::class.java
                    ) { view, value -> handler(view as V, value as T) }
                    currentId = newId
                    if (logger.isLoggable(Level.CONFIG)) {
                        logger.config("Registered attribute '$name' with ID $currentId and handler for ${V::class.java.simpleName}/${T::class.java.simpleName}.")
                    }
                }
            }
        }
    }

    /**
     * Applies a single attribute (identified by its name and value) to the given [View].
     *
     * This internal method looks up the attribute's ID and its corresponding [AttributeHandler].
     * It uses the [BitmaskManager] to ensure the attribute is applied only once per call to
     * [applyAttributes] on a single view, preventing redundant work.
     *
     * If the attribute name is not registered, this method does nothing.
     * The actual type checking and application logic are delegated to the [AttributeHandler].
     *
     * @param view The [View] to which the attribute should be applied.
     * @param name The string name of the attribute.
     * @param value The value of the attribute. Can be `null`.
     */
    @OptIn(ExperimentalContracts::class)
    internal fun applyAttributeInternal(view: View, name: String, value: Any?) {
        contract {
            // This contract implies that if the function returns normally, 'value' was not null
            // if the handler required a non-null value and successfully processed it.
            // However, the primary purpose of the contract here is more about flow analysis within this function.
            // A more accurate contract might be complex given the handler's own logic.
            // For simplicity, we keep it as is, acknowledging it's a soft implication.
            returns() implies (value != null || value == null) // More accurately, just returns implies execution finished.
        }

        val id = attributeIds[name] ?: return // If attribute name not registered, do nothing.
        if (bitmask.setIfNotSet(id)) { // Check bitmask: if true, attribute not yet applied in this pass.
            attributeHandlers[id]?.apply(view, value) // Apply using registered handler.
        }
    }

    /**
     * Applies a map of attributes to the given [View] in an optimized and specific order.
     *
     * The application order is crucial for correctness, especially with `ConstraintLayout`:
     * 1. **ID Attribute (`Attributes.Common.ID.name`):** Applied first, as other attributes or constraints
     *    might depend on the view's ID being set.
     * 2. **Normal Attributes:** All other attributes that are not related to `ConstraintLayout`.
     * 3. **Constraint Attributes (Pure):** `ConstraintLayout` attributes that are not bias-related
     *    (e.g., `layout_constraintStart_toStartOf`).
     * 4. **Bias Attributes:** `ConstraintLayout` bias attributes (e.g., `layout_constraintHorizontal_bias`).
     *    Bias attributes are often applied last as they adjust positioning based on other constraints.
     *
     * Before applying any attributes, the [bitmask] is cleared to ensure a fresh state for the current view.
     *
     * @param view The [View] instance to which the attributes will be applied.
     * @param attrs A [Map] where keys are attribute names (e.g., "android:text", "app:layout_constraintTop_toTopOf")
     *              and values are the corresponding attribute values.
     */
    fun applyAttributes(view: View, attrs: Map<String, Any?>) {
        bitmask.clear() // Clear the bitmask for this specific view's attribute application pass.

        // 1. Apply ID attribute first if present.
        attrs[Attributes.Common.ID.name]?.let { idValue ->
            applyAttributeInternal(view, Attributes.Common.ID.name, idValue)
        }

        // Partition attributes for ordered application.
        // Exclude ID attribute as it's already processed.
        val (constraintLayoutAttrs, normalAttrs) = attrs
            .filterNot { (key, _) -> key.isIDAttribute() }
            .partition { (key, _) -> key.isConstraintLayoutAttribute() }

        // 2. Apply normal attributes.
        normalAttrs.forEach { (name, value) ->
            applyAttributeInternal(view, name, value)
        }

        // Further partition ConstraintLayout attributes into pure constraints and bias attributes.
        val (pureConstraintAttrs, biasAttrs) = constraintLayoutAttrs
            .partition { (key, _) -> key.isConstraint() } // Filters out bias from constraints

        // 3. Apply pure ConstraintLayout attributes.
        pureConstraintAttrs.forEach { (name, value) ->
            applyAttributeInternal(view, name, value)
        }

        // 4. Apply ConstraintLayout bias attributes.
        biasAttrs.forEach { (name, value) ->
            applyAttributeInternal(view, name, value)
        }
    }

    /**
     * `AttributeHandler` is a wrapper class that holds the type information and the application logic
     * for a specific view attribute.
     *
     * It ensures type safety by checking if the target [View] instance is assignable from the
     * `viewClass` and if the attribute `value` is assignable from the `valueClass` (or is null)
     * before invoking the `handler` lambda.
     *
     * @property viewClass The [Class] of the [View] subtype this handler is for (e.g., `TextView::class.java`).
     * @property valueClass The [Class] of the attribute value this handler expects (e.g., `String::class.java`).
     * @property handler A lambda function `(View, Any?) -> Unit` that performs the actual attribute
     *                   application. It takes a generic [View] and an `Any?` value, but internally
     *                   these are safely cast based on `viewClass` and `valueClass` before invocation
     *                   by the `registerAttribute`'s capturing lambda.
     */
    class AttributeHandler(
        private val viewClass: Class<*>,
        private val valueClass: Class<*>,
        private val handler: (View, Any?) -> Unit,
    ) {
        /**
         * Applies the attribute `value` to the target `view` if the view and value types are compatible
         * with those specified by `viewClass` and `valueClass`.
         *
         * If the types are compatible, the `handler` lambda is invoked.
         * If not, a warning is logged, and the application is skipped for this handler. This might happen
         * if an attribute name is ambiguously used for different view/value types, though `registerAttribute`
         * should ideally handle distinct registrations.
         *
         * @param view The [View] instance to which the attribute should be applied.
         * @param value The attribute value. Can be `null`.
         */
        @OptIn(ExperimentalContracts::class)
        fun apply(view: View, value: Any?) {
            contract {
                // This contract is a hint to the compiler about the nullability of 'value'
                // if the handler implies non-nullability. However, 'value' can genuinely be null.
                // The main check is done by `valueClass.isInstance(value)`.
                returns() implies (value != null || value == null)
            }

            if (viewClass.isInstance(view) && (value == null || valueClass.isInstance(value))) {
                try {
                    handler(view, value)
                } catch (e: Exception) {
                    logger.log(Level.WARNING, "Attribute handler for ${view::class.java.simpleName} failed for value '$value'", e)
                }
            } else {
                // This case should ideally not be hit frequently if attributes are registered correctly
                // and ViewNode data is consistent.
                if (logger.isLoggable(Level.WARNING)) {
                    logger.warning(
                        "Type mismatch for attribute application. View: ${view::class.java.simpleName} (expected: ${viewClass.simpleName}), " +
                                "Value: ${value?.let { it::class.java.simpleName } ?: "null"} (expected: ${valueClass.simpleName})."
                    )
                }
            }
        }
    }

    /**
     * `BitmaskManager` provides a memory-efficient way to track the application state of attributes
     * for a single [View] during one pass of [applyAttributes].
     *
     * It uses a dynamically resizing [LongArray] as a bitset. Each bit corresponds to a unique
     * attribute ID (generated by [AttributeProcessor.nextId]). This allows for fast checking
     * ([setIfNotSet]) to see if an attribute has already been applied in the current context,
     * preventing redundant work (e.g., setting the same property multiple times).
     *
     * The bitmask is cleared ([clear]) at the beginning of each [applyAttributes] call for a new view.
     */
    private class BitmaskManager {
        /**
         * The underlying [LongArray] used as a bitset. Each element stores up to 64 attribute states.
         */
        private var bitmaskArray = LongArray(BITMAP_INITIAL_SIZE)

        /**
         * The current capacity of [bitmaskArray] in terms of `Long` elements.
         */
        private var currentSize = BITMAP_INITIAL_SIZE // Tracks the allocated size of bitmaskArray

        /**
         * Ensures that the [bitmaskArray] has enough capacity to store a bit at the given `index`.
         * If the required capacity (based on `index / BITS_PER_LONG`) exceeds the current array size,
         * the array is grown. The new size is the maximum of the required size and double the current size,
         * providing amortized constant time for additions.
         *
         * @param index The attribute ID (0-based) whose bit needs to be accessible.
         */
        @Suppress("NOTHING_TO_INLINE") // Inlining for performance in a hot path.
        private inline fun ensureCapacity(index: Int) {
            val requiredLongArrayIndex = index shr (BITS_PER_LONG.countLeadingZeroes() - 1 - 5) // Equivalent to index / 64 (integer division)
            // Corrected: BITS_PER_LONG is 64 (2^6). So, index / 64 is index shr 6.
            // Let's use BITS_PER_LONG directly if it's a power of 2.
            // BITS_PER_LONG is 64. log2(64) = 6. So, index shr 6.
            val wordIndex = index / BITS_PER_LONG // Simpler way to get array index

            if (wordIndex >= currentSize) {
                val newSize = (wordIndex + 1).coerceAtLeast(currentSize * 2)
                bitmaskArray = bitmaskArray.copyOf(newSize)
                currentSize = newSize
                if (logger.isLoggable(Level.FINEST)) {
                    logger.finest("BitmaskManager resized to $newSize longs for index $index.")
                }
            }
        }


        /**
         * Sets the bit corresponding to the given `index` if it has not already been set in this pass.
         *
         * @param index The attribute ID (0-based) to mark as applied.
         * @return `true` if the bit was successfully set (i.e., it was not previously set in this pass),
         *         `false` if the bit was already set.
         */
        @Suppress("NOTHING_TO_INLINE") // Inlining for performance.
        inline fun setIfNotSet(index: Int): Boolean {
            ensureCapacity(index)
            val wordIndex = index / BITS_PER_LONG      // Determine which Long in the array holds this bit.
            val bitPosition = index % BITS_PER_LONG // Determine the bit's position within that Long.
            val bit = 1L shl bitPosition          // Create a mask for that specific bit.

            return if ((bitmaskArray[wordIndex] and bit) == 0L) { // Check if bit is not set
                bitmaskArray[wordIndex] = bitmaskArray[wordIndex] or bit // Set the bit
                true
            } else {
                false // Bit was already set
            }
        }

        /**
         * Clears all bits in the bitmask, effectively resetting the state for a new view or
         * a new attribute application pass. It fills the underlying [bitmaskArray] with zeros.
         */
        @Suppress("NOTHING_TO_INLINE") // Inlining for performance.
        inline fun clear() {
            bitmaskArray.fill(0L)
        }
    }

    // --- String extension functions for optimized attribute type checking ---

    /**
     * Checks if an attribute name string starts with "layout_constraint", indicating it's a
     * `ConstraintLayout` attribute. Case-insensitive.
     * @return `true` if it's a ConstraintLayout attribute, `false` otherwise.
     */
    @Suppress("NOTHING_TO_INLINE")
    private inline fun String.isConstraintLayoutAttribute(): Boolean =
        this.startsWith(LAYOUT_CONSTRAINT_PREFIX, ignoreCase = true)

    /**
     * Checks if an attribute name string is a "pure" `ConstraintLayout` attribute,
     * meaning it's a constraint attribute but not a bias attribute. Case-insensitive.
     * @return `true` if it's a pure constraint attribute, `false` otherwise.
     */
    @Suppress("NOTHING_TO_INLINE")
    private inline fun String.isConstraint(): Boolean =
        this.isConstraintLayoutAttribute() && !this.contains(BIAS_KEYWORD, ignoreCase = true)

    /**
     * Checks if an attribute name string is a `ConstraintLayout` bias attribute. Case-insensitive.
     * @return `true` if it's a bias attribute, `false` otherwise.
     */
    @Suppress("NOTHING_TO_INLINE")
    private inline fun String.isBias(): Boolean =
        this.isConstraintLayoutAttribute() && this.contains(BIAS_KEYWORD, ignoreCase = true)

    /**
     * Checks if an attribute name string is the common ID attribute ("id"). Case-insensitive.
     * @return `true` if it's the ID attribute, `false` otherwise.
     */
    @Suppress("NOTHING_TO_INLINE")
    private inline fun String.isIDAttribute(): Boolean =
        this.equals(Attributes.Common.ID.name, ignoreCase = true)
}
