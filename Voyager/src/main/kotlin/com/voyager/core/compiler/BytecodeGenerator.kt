package com.voyager.core.compiler

import android.content.Context
import android.view.View
import com.voyager.core.model.ViewNode
import com.voyager.core.view.ViewFactory
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer
import java.nio.ByteOrder

//make the layoutCompiler to be in the c++ code integrated with the xml straightly and make the output is Bytecode structure and when backing the results to the kt code make it as stream to avoid the string allocations and these things and make the Bytecode header to contain the activity name and when returning the bytecode result make the code to handle it and be ware of saving the result for the activity reopens

/**
 * Bytecode generator for creating optimized layout instructions.
 *
 * This generator creates a custom instruction set for maximum performance:
 * - Compact binary format
 * - Type-safe operations
 * - Minimal memory footprint
 * - Fast execution
 *
 * Instruction Format:
 * [OpCode:1byte][DataLength:4bytes][Data:variable]
 */
class BytecodeGenerator() {
    private val output = ByteArrayOutputStream()
    private val buffer = ByteBuffer.allocate(1024).order(ByteOrder.LITTLE_ENDIAN)

    /**
     * Writes the bytecode header with version and metadata.
     */
    fun writeHeader(rootNode: ViewNode) {
        writeRawByte(BYTECODE_VERSION)
        writeInt(System.currentTimeMillis().toInt()) // Compilation timestamp
        writeString(rootNode.type) // Root view type
        writeInt(countTotalViews(rootNode)) // Total view count for allocation hints
    }

    /**
     * Writes a single instruction with opcode and data.
     */
    fun writeInstruction(opCode: OpCode, vararg data: Any) {
        writeRawByte(opCode.value)

        when (opCode) {
            OpCode.CREATE_VIEW -> {
                writeString(data[0] as String) // View type
            }

            OpCode.SET_ATTRIBUTE -> {
                writeString(data[0] as String) // Attribute name
                writeValue(data[1]) // Attribute value
            }

            OpCode.SET_LAYOUT_PARAMS -> {
                // Layout params are encoded as key-value pairs
                writeInt(data.size / 2) // Number of params
                for (i in data.indices step 2) {
                    writeString(data[i] as String) // Param name
                    writeValue(data[i + 1]) // Param value
                }
            }

            OpCode.ADD_CHILD -> {
                writeInt(data[0] as Int) // Parent view index
                writeInt(data[1] as Int) // Child view index
            }

            OpCode.SET_ID -> {
                writeString(data[0] as String) // View ID
            }

            OpCode.OPTIMIZE_HINT -> {
                writeString(data[0] as String) // Optimization type
                writeString(data[1] as String) // Optimization data
            }

            OpCode.FINALIZE -> {
                // Finalize instruction has no data
            }
        }
    }

    /**
     * Writes a view ID instruction.
     */
    fun writeViewId(id: String) {
        if (id.isNotEmpty()) {
            writeInstruction(OpCode.SET_ID, id)
        }
    }

    /**
     * Writes finalization instructions.
     */
    fun writeFinalization() {
        writeInstruction(OpCode.FINALIZE)
        writeRawByte(BYTECODE_END_MARKER)
    }

    /**
     * Returns the generated bytecode as a byte array.
     */
    fun toByteArray(): ByteArray {
        return output.toByteArray()
    }

    // Private helper methods
    private fun writeRawByte(value: Int) {
        output.write(value)
    }

    private fun writeInt(value: Int) {
        buffer.clear()
        buffer.putInt(value)
        output.write(buffer.array(), 0, 4)
    }

    private fun writeString(value: String) {
        val bytes = value.toByteArray(Charsets.UTF_8)
        writeInt(bytes.size)
        output.write(bytes)
    }

    private fun writeValue(value: Any) {
        when (value) {
            is String -> {
                writeRawByte(TYPE_STRING)
                writeString(value)
            }

            is Int -> {
                writeRawByte(TYPE_INT)
                writeInt(value)
            }

            is Float -> {
                writeRawByte(TYPE_FLOAT)
                buffer.clear()
                buffer.putFloat(value)
                output.write(buffer.array(), 0, 4)
            }

            is Boolean -> {
                writeRawByte(TYPE_BOOLEAN)
                writeRawByte(if (value) 1 else 0)
            }

            else -> {
                writeRawByte(TYPE_STRING)
                writeString(value.toString())
            }
        }
    }

    private fun countTotalViews(node: ViewNode): Int {
        return 1 + node.children.sumOf { countTotalViews(it) }
    }

    companion object {
        private const val BYTECODE_VERSION: Int = 1
        private const val BYTECODE_END_MARKER: Int = 0xFF

        // Type markers
        private const val TYPE_STRING: Int = 0x01
        private const val TYPE_INT: Int = 0x02
        private const val TYPE_FLOAT: Int = 0x03
        private const val TYPE_BOOLEAN: Int = 0x04
    }
}

/**
 * Bytecode operation codes for layout instructions.
 */
enum class OpCode(val value: Int) {
    CREATE_VIEW(0x10), SET_ATTRIBUTE(0x20), SET_LAYOUT_PARAMS(0x30), ADD_CHILD(0x40), SET_ID(0x50), OPTIMIZE_HINT(
        0x60
    ),
    FINALIZE(0xF0)
}

/**
 * Bytecode interpreter for executing compiled layouts.
 * This interpreter provides maximum performance by directly executing
 * bytecode instructions without intermediate parsing.
 */
class BytecodeInterpreter(private val context: Context) {
    private val viewStack = ArrayList<View>()
    private val viewMap = mutableMapOf<String, View>()

    /**
     * Executes the bytecode and returns the resulting view hierarchy.
     */
    fun execute(bytecode: ByteArray): View? {
        val buffer = ByteBuffer.wrap(bytecode).order(ByteOrder.LITTLE_ENDIAN)

        // Read header
        val version = buffer.get().toInt()
        if (version != 1) {
            throw IllegalArgumentException("Unsupported bytecode version: $version")
        }

        buffer.int
        readString(buffer)
        val totalViews = buffer.int

        // Initialize view stack with capacity
        viewStack.clear()
        viewStack.ensureCapacity(totalViews)

        // Execute instructions
        while (buffer.hasRemaining()) {
            val opCode = buffer.get().toInt()

            when (opCode) {
                OpCode.CREATE_VIEW.value -> executeCreateView(buffer)
                OpCode.SET_ATTRIBUTE.value -> executeSetAttribute(buffer)
                OpCode.SET_LAYOUT_PARAMS.value -> executeSetLayoutParams(buffer)
                OpCode.ADD_CHILD.value -> executeAddChild(buffer)
                OpCode.SET_ID.value -> executeSetId(buffer)
                OpCode.OPTIMIZE_HINT.value -> executeOptimizeHint(buffer)
                OpCode.FINALIZE.value -> break
                0xFF -> break // End marker
                else -> throw IllegalArgumentException("Unknown opcode: $opCode")
            }
        }

        return viewStack.firstOrNull()
    }

    private fun executeCreateView(buffer: ByteBuffer) {
        val viewType = readString(buffer)
        val view = ViewFactory.createView(context, viewType)
        viewStack.add(view)
    }

    private fun executeSetAttribute(buffer: ByteBuffer) {
        val attributeName = readString(buffer)
        val attributeValue = readValue(buffer)

        val currentView = viewStack.lastOrNull()
        currentView?.let { view ->
            applyAttribute(view, attributeName, attributeValue)
        }
    }

    private fun executeSetLayoutParams(buffer: ByteBuffer) {
        val paramCount = buffer.int
        val currentView = viewStack.lastOrNull()

        for (i in 0 until paramCount) {
            val paramName = readString(buffer)
            val paramValue = readValue(buffer)

            currentView?.let { view ->
                applyLayoutParam(view, paramName, paramValue)
            }
        }
    }

    private fun executeAddChild(buffer: ByteBuffer) {
        val parentIndex = buffer.int
        val childIndex = buffer.int

        if (parentIndex < viewStack.size && childIndex < viewStack.size) {
            val parent = viewStack[parentIndex] as? android.view.ViewGroup
            val child = viewStack[childIndex]
            parent?.addView(child)
        }
    }

    private fun executeSetId(buffer: ByteBuffer) {
        val id = readString(buffer)
        val currentView = viewStack.lastOrNull()

        currentView?.let { view ->
            viewMap[id] = view
            // Set Android view ID if available
            val resourceId = context.resources.getIdentifier(id, "id", context.packageName)
            if (resourceId != 0) {
                view.id = resourceId
            }
        }
    }

    private fun executeOptimizeHint(buffer: ByteBuffer) {
        val optimizationType = readString(buffer)
        val optimizationData = readString(buffer)

        // Apply optimization hints
        val currentView = viewStack.lastOrNull()
        currentView?.let { view ->
            applyOptimizationHint(view, optimizationType, optimizationData)
        }
    }

    // Helper methods for bytecode execution
    private fun readString(buffer: ByteBuffer): String {
        val length = buffer.int
        val bytes = ByteArray(length)
        buffer.get(bytes)
        return String(bytes, Charsets.UTF_8)
    }

    private fun readValue(buffer: ByteBuffer): Any {
        val type = buffer.get().toInt()
        return when (type) {
            0x01 -> readString(buffer) // STRING
            0x02 -> buffer.int // INT
            0x03 -> buffer.float // FLOAT
            0x04 -> buffer.get().toInt() == 1 // BOOLEAN
            else -> throw IllegalArgumentException("Unknown value type: $type")
        }
    }

    private fun createViewFromType(viewType: String): View {
        // Create view instance based on type
        return ViewFactory.createView(context, viewType)
    }

    private fun applyAttribute(view: View, name: String, value: Any) {
        // Apply attribute to view using reflection or direct calls
        when (name) {
            "android:text" -> (view as? android.widget.TextView)?.text = value.toString()
            "android:background" -> {
                // Handle background setting
            }
            // Add more attribute handlers as needed
        }
    }

    private fun applyLayoutParam(view: View, name: String, value: Any) {
        // Apply layout parameters
        when (name) {
            "android:layout_width" -> {
                // Handle layout width
            }

            "android:layout_height" -> {
                // Handle layout height
            }
        }
    }

    private fun applyOptimizationHint(view: View, type: String, data: String) {
        // Apply optimization hints to improve performance
        when (type) {
            "cache_enabled" -> {
                // Enable view caching
                view.tag = "cached_view"
            }

            "preload_resources" -> {
                // Preload resources
            }
        }
    }
}