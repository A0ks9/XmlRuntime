package com.dynamic.plugin

import org.gradle.api.DefaultTask
import org.gradle.api.file.ConfigurableFileCollection
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.CacheableTask
import org.gradle.api.tasks.IgnoreEmptyDirectories
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.InputFiles
import org.gradle.api.tasks.OutputFile
import org.gradle.api.tasks.PathSensitive
import org.gradle.api.tasks.PathSensitivity
import org.gradle.api.tasks.TaskAction
import org.gradle.work.Incremental
import org.slf4j.LoggerFactory
import java.io.File
import java.nio.file.Files
import java.security.DigestInputStream
import java.security.MessageDigest
import java.util.EnumMap
import java.util.regex.Pattern
import javax.inject.Inject

@CacheableTask
abstract class GenerateResourcesTask @Inject constructor() : DefaultTask() {

    @get:PathSensitive(PathSensitivity.RELATIVE)
    @get:IgnoreEmptyDirectories
    @get:Incremental
    @get:InputFiles
    abstract val valuesFiles: ConfigurableFileCollection

    @get:Input
    abstract val packageName: Property<String>

    @get:OutputFile
    abstract val outputFile: RegularFileProperty

    private val hashFile by lazy {
        project.layout.buildDirectory.file("generated/kt-resources/com/dynamic/resources/ResourcesBridge.hash")
            .get().asFile
    }

    private enum class ResourceType(val tag: String) {
        COLOR("color"), STRING("string"), STYLE("style"), DIMEN("dimen"), ATTR("attr")
    }

    companion object {
        private val PATTERNS = enumValues<ResourceType>().associateWith {
            Pattern.compile("""<${it.tag}[^>]*?name\s*=\s*["']([^"']+)["']""", Pattern.DOTALL)
        }
        private const val HEX_FORMAT = "%02x"
        private val logger = LoggerFactory.getLogger(GenerateResourcesTask::class.java)
    }

    @TaskAction
    fun generateBridge() {
        if (valuesFiles.files.isEmpty()) {
            logger.info("No values files found. Skipping ResourcesBridge generation.")
            return
        }

        if (isUpToDate()) {
            logger.info("ResourcesBridge is up-to-date. Skipping generation.")
            return
        }

        logger.info("Generating ResourcesBridge...")
        val resources = extractAllResources()
        generateKotlinCode(resources)
        logger.info("ResourcesBridge generated successfully.")
    }

    private fun isUpToDate(): Boolean {
        if (!outputFile.get().asFile.exists() || !hashFile.exists()) {
            return false
        }
        if (!valuesFiles.files.all { it.exists() }) {
            return false
        }

        val currentHash = calculateHash()
        val previousHash = hashFile.readText()

        return previousHash == currentHash
    }

    private fun calculateHash(): String {
        val digest = MessageDigest.getInstance("SHA-256")
        val buffer = ByteArray(8192)
        valuesFiles.files.filter(File::exists).forEach { file ->
            DigestInputStream(file.inputStream().buffered(), digest).use { stream ->
                while (stream.read(buffer) != -1) { /* Reading for digest calculation */
                }
            }
        }
        return digest.digest().joinToString("") { HEX_FORMAT.format(it) }
    }

    private fun extractAllResources(): Map<ResourceType, Set<String>> {
        val resourcesMap = EnumMap<ResourceType, MutableSet<String>>(ResourceType::class.java)
        ResourceType.entries.forEach { resourcesMap[it] = LinkedHashSet() }

        valuesFiles.files.filter(File::exists).forEach { file ->
            try {
                file.useLines { lines ->
                    lines.forEach { line ->
                        PATTERNS.forEach { (type, pattern) ->
                            val matcher = pattern.matcher(line)
                            if (matcher.find()) {
                                val name = matcher.group(1)
                                val cleanName =
                                    if (type == ResourceType.STYLE) name.replace('.', '_') else name
                                resourcesMap[type]?.add(cleanName)
                            }
                        }
                    }
                }
            } catch (e: Exception) {
                logger.error("Error processing file: ${file.path}", e)
                // Consider throwing exception or handling it based on your error handling policy
            }
        }
        return resourcesMap
    }

    private fun generateKotlinCode(resources: Map<ResourceType, Set<String>>) {
        val output = outputFile.get().asFile.apply { parentFile?.mkdirs() }
        try {
            Files.writeString(output.toPath(), buildString {
                appendLine("// This file is generated by GenerateResourcesTask. Do not edit manually.")
                appendLine("@file:JvmName(\"ResourcesBridge\")")
                appendLine("package com.dynamic.resources\n")
                appendLine("import android.content.Context")
                appendLine("import androidx.core.content.ContextCompat")
                appendLine("import ${packageName.get()}.R\n")

                ResourceType.entries.forEach { type ->
                    val returnType = when (type) {
                        ResourceType.COLOR, ResourceType.STYLE, ResourceType.ATTR -> "Int" // Resource IDs are Int
                        ResourceType.STRING -> "String"
                        ResourceType.DIMEN -> "Float"
                    }
                    val defaultValue = when (returnType) {
                        "String" -> "\"\""
                        "Float" -> "0f"
                        else -> "0"
                    }

                    append("fun get").append(
                        type.name.lowercase().replaceFirstChar { it.uppercase() })
                        .append("(context: Context, name: String): ").append(returnType)
                        .append(" = when (name) {").appendLine()

                    resources[type]?.forEach { name ->
                        append("    \"").append(name).append("\" -> ")
                        when (type) {
                            ResourceType.COLOR -> append("ContextCompat.getColor(context, R.color.").append(
                                name
                            ).append(")")

                            ResourceType.STRING -> append("context.getString(R.string.").append(name)
                                .append(")")

                            ResourceType.STYLE -> append("R.style.").append(name)
                            ResourceType.DIMEN -> append("context.resources.getDimension(R.dimen.").append(
                                name
                            ).append(")")

                            ResourceType.ATTR -> append("R.attr.").append(name)
                        }
                        appendLine()
                    }
                    append("    else -> ").append(defaultValue)
                    appendLine().append("}")
                    appendLine()
                }
            })
            Files.writeString(hashFile.toPath(), calculateHash())
        } catch (e: Exception) {
            logger.error("Error writing generated Kotlin code to file: ${output.path}", e)
        }
    }
}